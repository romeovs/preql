package preql

import (
	"strings"
	"text/template"
)

var templ = template.Must(template.New("template").Parse(strings.Trim(`
// Code generated by scanner. DO NOT EDIT.

package {{.Name}}

import (
  "context"

  "github.com/romeovs/preql/sql"
)

{{- range .ScannableTypes }}
{{- $receiver := .Receiver }}

// Scan scans the columns of the current row of rows into {{.Receiver}}.
// Expects rows.Next to be called at least once already.
func ({{.Receiver}} *{{.Name}}) Scan(rows *sql.Rows) error {
	names, err := rows.Columns()
	if err != nil {
		return err
	}

	// Undefined columns are ignored.
	var null interface{}

	scan := make([]interface{}, len(names))
	for i, name := range names {
		switch name {
		{{- range $column, $field := .Fields }}
		case "{{$column}}":
			scan[i] = &{{$receiver}}.{{$field}}
		{{- end }}
		default:
			scan[i] = &null
		}
	}

	return rows.Scan(scan...)
}

// ScanOne scans one row from rows into {{.Receiver}}.
func ({{.Receiver}} *{{.Name}}) ScanOne(rows *sql.Rows) error {
	if !rows.Next() {
		if err := rows.Err(); err != nil {
			return err
		}
		return sql.ErrNoRows
	}

  return {{.Receiver}}.Scan(rows)
}
{{- end }}

{{- range .Queries }}
{{ if eq .Type "query" }}
// preql{{.Name}} implements the query associated with {{.Name}} in it's doc comment.
func preql{{.Name}}(sql sql.Interface, {{.Arguments}}) (*sql.Rows, error) {
	return sql.QueryContext({{.Params}})
}
{{- end}}

{{- if eq .Type "exec" }}
// preql{{.Name}} implements the query associated with {{.Name}} in it's doc comment.
func preql{{.Name}}(sql sql.Interface, {{.Arguments}}) (sql.Result, error) {
	return sql.ExecContext({{.Params}})
}
{{- end}}
{{- end}}
`, " \n")))
